package com.manyseries;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Paint.Align;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;

import org.achartengine.ChartFactory;
import org.achartengine.GraphicalView;
import org.achartengine.chart.PointStyle;
import org.achartengine.model.XYMultipleSeriesDataset;
import org.achartengine.model.XYSeries;
import org.achartengine.renderer.XYMultipleSeriesRenderer;
import org.achartengine.renderer.XYSeriesRenderer;

import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

public class MainActivity extends AppCompatActivity {

    private Timer timer = new Timer();
    private TimerTask task;
    private Handler handler;
    private String title = "quxian";
    private XYSeries series;
    private XYMultipleSeriesDataset mDataset;
    private GraphicalView chart;
    private XYMultipleSeriesRenderer renderer;
    private Context context;
    private int addX = -1, addY;
    /**
     * 实时图整段刷新，背景图图分段刷新
     */
    private int totalserise = 1 + 5;
    private int count = 0;
    //    double[] xv = new double[1024];
//    double[] yv = new double[1024];
    List<int[]> plist;
    List<int[]> mlist;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        for (int a = 0; a < 10; a++) {
            plist = new ArrayList<>();
            for (int i = 1; i < 6; i++) {
                int[] data = new int[1026];
                data[0] = 5;
                data[1] = i;
                for (int j = 0; j < 1024; j++) {
                    int dataY = (int) (Math.random() * 50);
                    data[j + 2] = dataY;
                }
                plist.add(data);
            }
            Constant.queue_sweep.offer(plist);
        }
        for (int bb = 0; bb < 1; bb++) {
            for (int i = 1; i < 6; i++) {
                int[] data = new int[1026];
                data[0] = 5;
                data[1] = i;
                for (int j = 0; j < 1024; j++) {
                    int dataY = (int) (Math.random() * 50);
                    data[j + 2] = dataY;
                }
                Constant.queue_back.offer(data);
            }
        }

        context = getApplicationContext();

        // 这里获得main界面上的布局，下面会把图表画在这个布局里面
        LinearLayout layout = (LinearLayout) findViewById(R.id.linearLayout1);

        // 这个类用来放置曲线上的所有点，是一个点的集合，根据这些点画出曲线
        series = new XYSeries(title);

        // 创建一个数据集的实例，这个数据集将被用来创建图表
        // mDataset = new XYMultipleSeriesDataset();
        mDataset = buildDataset(title);

        // 将点集添加到这个数据集中
        // mDataset.addSeries(series);


        // 以下都是曲线的样式和属性等等的设置，renderer相当于一个用来给图表做渲染的句柄
        int[] color = new int[]{Color.GREEN, Color.RED};
        PointStyle style = PointStyle.CIRCLE;
        renderer = buildRenderer(color, style, true);

        int start = 0;
        int endX = 0;
        // 设置好图表的样式
        setChartSettings(renderer, "X", "Y", 70, 195, 0, 90, Color.WHITE,
                Color.WHITE);


        // 生成图表
        chart = ChartFactory.getLineChartView(context, mDataset, renderer);

        // 将图表添加到布局中去
        layout.addView(chart, new LayoutParams(LayoutParams.MATCH_PARENT,
                LayoutParams.WRAP_CONTENT));


        // 这里的Handler实例将配合下面的Timer实例，完成定时更新图表的功能
        handler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                // 刷新图表
                updateChart();
                super.handleMessage(msg);
            }
        };

        task = new TimerTask() {
            @Override
            public void run() {
                Message message = new Message();
                message.what = 1;
                handler.sendMessage(message);
            }
        };

        timer.schedule(task, 1000, 1000);


    }

    @Override
    public void onDestroy() {
        // 当结束程序时关掉Timer
        timer.cancel();
        super.onDestroy();
    }

    protected XYMultipleSeriesDataset buildDataset(String titles)
//                                                   double[] xValues,
//                                                   double[] yValues)
    {
        XYMultipleSeriesDataset dataset = new XYMultipleSeriesDataset();

        int length = totalserise;            //有几条线
        for (int i = 0; i < length; i++) {
            XYSeries series = new XYSeries(titles);    //根据每条线的名称创建
//            double[] xV = xValues.get(i);                 //获取第i条线的数据
//            double[] yV = yValues.get(i);
            //  int seriesLength = xV.length;                 //有几个点

//            for (int k = 0; k < seriesLength; k++)        //每条线里有几个点
//            {
//                series.add(xV[k], yV[k]);
//            }

            dataset.addSeries(series);
        }

        return dataset;
    }

    protected XYMultipleSeriesRenderer buildRenderer(int[] color,
                                                     PointStyle style, boolean fill) {
        XYMultipleSeriesRenderer renderer = new XYMultipleSeriesRenderer();

        // 设置图表中曲线本身的样式，包括颜色、点的大小以及线的粗细等

        int length = totalserise;

        //背景图
        for (int i = 0; i < length-1; i++) {
            XYSeriesRenderer r = new XYSeriesRenderer();
            r.setColor(color[1]);
            r.setPointStyle(style);
            r.setFillPoints(fill);
            r.setLineWidth(5);
            renderer.addSeriesRenderer(r);
        }
        XYSeriesRenderer r1 = new XYSeriesRenderer();
        r1.setColor(color[0]);
        r1.setPointStyle(style);
        r1.setFillPoints(fill);
        r1.setLineWidth(5);
        renderer.addSeriesRenderer(r1);

        return renderer;
    }

    protected void setChartSettings(XYMultipleSeriesRenderer renderer,
                                    String xTitle, String yTitle, double xMin, double xMax,
                                    double yMin, double yMax, int axesColor, int labelsColor) {
        // 有关对图表的渲染可参看api文档
        renderer.setChartTitle("曲线图");//
        renderer.setXTitle(xTitle);
        renderer.setYTitle(yTitle);
        renderer.setXAxisMin(xMin);
        renderer.setXAxisMax(xMax);
        renderer.setYAxisMin(yMin);
        renderer.setYAxisMax(yMax);
        renderer.setAxesColor(axesColor);
        renderer.setLabelsColor(labelsColor);
        renderer.setShowGrid(true);
        renderer.setGridColor(Color.GREEN);
        renderer.setXLabels(20);
        renderer.setYLabels(10);
        renderer.setXTitle("Time");
        renderer.setYTitle("dBm");
        renderer.setYLabelsAlign(Align.RIGHT);
        renderer.setPointSize((float) 2);
        renderer.setShowLegend(false);
        renderer.setZoomEnabled(true);// 设置渲染器允许放大缩小
        renderer.setZoomButtonsVisible(true);
        /**以下为自己修改
         *
         */
        //设定背景颜色
        renderer.setApplyBackgroundColor(true);
        renderer.setBackgroundColor(Color.BLACK);
        renderer.setBarSpacing(1);
    }

    private void updateChart() {
        mlist = new ArrayList<>();
        // 设置好下一个需要增加的节点
        addX = 0;
        addY = (int) (Math.random() * 90);
        // 移除数据集中旧的点集
        double[] xv = new double[1024];
        double[] yv = new double[1024];
        double[] xv_back = new double[1024];
        double[] yv_back = new double[1024];
        //  mDataset.removeSeries(series);

        if (!Constant.queue_sweep.isEmpty()) {
            Log.d("xys", "update!!!!!!!!!!!!!!!");
            mlist = Constant.queue_sweep.poll();
            int size = mlist.size();
            for (int mm = 0; mm < size; mm++) {
                int[] data = mlist.get(mm);
                int total = data[0];
                double dataX = (data[1] - 1) * 25 + 70;
                int circle = 1024 / total;
                int flag = 0;
                for (int i = 0; i < circle; i++) {
                    int max = data[2 + i * total];
                    for (int j = 0; j < total; j++) {
                        if (data[i * total + j + 2] >= max) {
                            max = data[i * total + j + 2];
                            flag = i * total + j + 2;
                        }
                    }
                    xv[i + mm * circle] = dataX + flag * 25.0 / 1024.0;
                    yv[i + mm * circle] = max;
                }
            }
            series = mDataset.getSeriesAt(5);
            mDataset.removeSeries(5);

            // 点集先清空，为了做成新的点集而准备
            series.clear();

            // 将新产生的点首先加入到点集中，然后在循环体中将坐标变换后的一系列点都重新加入到点集中
            // 这里可以试验一下把顺序颠倒过来是什么效果，即先运行循环体，再添加新产生的点
            // series.add(addX, addY);
            for (int k = 0; k < 1024; k++) {
                series.add(xv[k], yv[k]);
            }


            // 在数据集中添加新的点集
            mDataset.addSeries(5, series);

            // 视图更新，没有这一步，曲线不会呈现动态
            // 如果在非UI主线程中，需要调用postInvalidate()，具体参考api
            chart.invalidate();

            //   }
        }
        if (!Constant.queue_back.isEmpty()) {
            int[] data = Constant.queue_back.poll();
            int total = data[0];
            if (count == total) {
                count = 0;
            }
            count++;
            double dataX = (data[1] - 1) * 25 + 70;
            int circle = 1024 / total;
            int flag = 0;
            for (int i = 0; i < circle; i++) {
                int max = data[2 + i * total];
                for (int j = 0; j < total; j++) {
                    if (data[i * total + j + 2] >= max) {
                        max = data[i * total + j + 2];
                        flag = i * total + j + 2;
                    }
                }
                xv_back[i] = dataX + flag * 25.0 / 1024.0;
                yv_back[i] = max;
            }

            series = mDataset.getSeriesAt(count-1);
            mDataset.removeSeries(count-1);
            series.clear();
            for (int k = 0; k < circle; k++) {
                series.add(xv_back[k], yv_back[k]);
            }
            // 在数据集中添加新的点集
            mDataset.addSeries(count-1, series);
            chart.invalidate();
        }


    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

}





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































        



